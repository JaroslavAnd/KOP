<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: useGameLogic.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: useGameLogic.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { useState, useEffect, useCallback } from 'react';
import { useGameStore } from '../store/useGameStore';

/**
 * @module useGameLogic
 * @description Користувацький хук для управління основною логікою математичної гри.
 * Відповідає за таймер, генерацію прикладів, перевірку відповідей та збереження результатів.
 * * @returns {Object} Об'єкт зі станом гри та функціями управління.
 * @property {number} timeLeft - Час, що залишився до кінця гри (в секундах).
 * @property {number} score - Поточний рахунок гравця.
 * @property {Object} currentProblem - Об'єкт поточного прикладу.
 * @property {string} currentProblem.text - Текст прикладу для відображення.
 * @property {number} currentProblem.answer - Правильна математична відповідь.
 * @property {string} userAnswer - Поточна відповідь, яку ввів користувач.
 * @property {boolean} isGameOver - Прапорець, що вказує на завершення гри.
 * @property {boolean} isGameActive - Прапорець, що вказує, чи гра зараз триває.
 * @property {Function} setUserAnswer - Функція для оновлення введеної відповіді користувача.
 * @property {Function} handleAnswerSubmit - Функція для перевірки відповіді та нарахування балів.
 * @property {Function} restartGame - Функція для перезапуску гри з поточними налаштуваннями.
 */
export const useGameLogic = () => {
  const settings = useGameStore((state) => state.settings);
  const addResult = useGameStore((state) => state.addResult);
  const currentUser = useGameStore((state) => state.currentUser);
  
  const [timeLeft, setTimeLeft] = useState(settings.gameTime);
  const [score, setScore] = useState(0);
 
  const [currentProblem, setCurrentProblem] = useState({ text: 'Завантаження...', answer: 0 }); 
  const [userAnswer, setUserAnswer] = useState('');
  const [isGameActive, setIsGameActive] = useState(true);
  const [isGameOver, setIsGameOver] = useState(false);

  /**
   * Генерує новий математичний приклад на основі обраного рівня складності.
   * Оновлює стан `currentProblem`.
   * @function
   * @private
   */
  const generateProblem = useCallback(() => {
    let a, b, operator, problemText, correctAnswer;

    const difficulty = settings.difficulty;

    if (difficulty === 'easy') {
     
      operator = '+';
      a = Math.floor(Math.random() * 10) + 1;
      b = Math.floor(Math.random() * 10) + 1;
      correctAnswer = a + b;
      problemText = `${a} + ${b}`;

    } else if (difficulty === 'medium') {
    
      const operators = ['+', '-', '*'];
      operator = operators[Math.floor(Math.random() * operators.length)];

      if (operator === '*') {
       
        a = Math.floor(Math.random() * 11) + 2; 
        b = Math.floor(Math.random() * 11) + 2; 
        correctAnswer = a * b;
        problemText = `${a} × ${b}`; 
      } else {
       
        a = Math.floor(Math.random() * 30) + 1;
        b = Math.floor(Math.random() * 30) + 1;
        if (operator === '-' &amp;&amp; a &lt; b) {
          [a, b] = [b, a]; 
        }
        correctAnswer = (operator === '+') ? a + b : a - b;
        problemText = `${a} ${operator} ${b}`;
      }

    } else { 
  
      const operators = ['+', '-', '*', '/'];
      operator = operators[Math.floor(Math.random() * operators.length)];

      if (operator === '/') {
     
        const result = Math.floor(Math.random() * 10) + 2; 
        b = Math.floor(Math.random() * 10) + 2;           
        a = result * b; 
        correctAnswer = result;
        problemText = `${a} ÷ ${b}`; 
      } else if (operator === '*') {

        a = Math.floor(Math.random() * 16) + 5; 
        b = Math.floor(Math.random() * 16) + 5; 
        correctAnswer = a * b;
        problemText = `${a} × ${b}`;
      } else {
        a = Math.floor(Math.random() * 91) + 10; 
        b = Math.floor(Math.random() * 91) + 10; 
        if (operator === '-' &amp;&amp; a &lt; b) {
          [a, b] = [b, a]; 
        }
        correctAnswer = (operator === '+') ? a + b : a - b;
        problemText = `${a} ${operator} ${b}`;
      }
    }

    setCurrentProblem({
      text: problemText,
      answer: correctAnswer,
    });
    
  }, [settings.difficulty]);


  useEffect(() => {
    generateProblem();
  }, [generateProblem]);

  useEffect(() => {
    if (!isGameActive) return;
    if (timeLeft === 0) {
      setIsGameActive(false); 
      setIsGameOver(true);    
      addResult({
        score: score,
        difficulty: settings.difficulty,
        gameTime: settings.gameTime,
        userName: currentUser,
        date: new Date().toISOString(),
      });
      return;
    }
    const timerId = setInterval(() => {
      setTimeLeft((prevTime) => prevTime - 1);
    }, 1000);
    return () => clearInterval(timerId);
  }, [timeLeft, isGameActive, score, settings, addResult, currentUser]);

  /**
   * Обробляє сабміт відповіді користувачем.
   * Перевіряє правильність, збільшує рахунок (якщо вірно), очищає поле вводу та генерує новий приклад.
   * @function
   */
  const handleAnswerSubmit = () => {
    if (!isGameActive || !userAnswer) return;

    if (parseInt(userAnswer, 10) === currentProblem.answer) {
      setScore((prevScore) => prevScore + 10);
    }
    
    setUserAnswer('');
    generateProblem();
  };

  /**
   * Перезапускає гру з початковими налаштуваннями часу та рахунку.
   * @function
   */
  const restartGame = () => {
    setTimeLeft(settings.gameTime);
    setScore(0);
    setIsGameOver(false);
    setIsGameActive(true);
    generateProblem();
  };

  return {
    timeLeft,
    score,
    currentProblem, 
    userAnswer,
    isGameOver,
    isGameActive, 
    setUserAnswer,
    handleAnswerSubmit,
    restartGame,
  };
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-useGameLogic.html">useGameLogic</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Feb 12 2026 11:11:27 GMT+0200 (за східноєвропейським стандартним часом)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
